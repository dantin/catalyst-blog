---
title: B+树
date: 2016-09-18 15:30:30
categories: 学术
tags: Algorithm
toc: true
---

B+树是一种能够优雅地根据文件变化动态调整的数据结构，它广泛应用于数据库和文件系统中，支持等于和范围查询。

B+树的核心是一个平衡树。使用内部节点辅助查询，用叶子节点保存数据。叶子节点是一个双向链表，方便双向遍历。B+树能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入，这与二叉树恰好相反。

B+树特点：
* 插入、删除等操作能保证B+树平衡。时间复杂度是LogfN，f=fanout，N=页面的数量；
* 则除了根之外的每个节点都保证最少50%的利用率（实际上，删除很少发生，大多数都是增加）每个节点包含m个元素，d <= m <= 2d。d为树的序数；
* 每次查询都从根搜索到对应的叶子节点，在fanout比较大的情况下树的高度一般很少超过4级。

### 插入

B+树的插入算法如下：

| 叶子页满? | 索引页满？| 动作 |
|:--------:|:-------:|-----|
| No       | No      | 把记录放在叶子节点的响应位置 |
| Yes      | No      | 1. 分裂叶子节点；<br/>2. 把中间节点放到索引节点中；<br/>3. 左叶子节点包含比中间节点小的键；<br/>4. 右叶子节点包含比大于等于中间节点的键 |
| Yes      | Yes     | 1. 分裂叶子节点；<br/>2. 小于中间节点的项在左叶子；<br/>3. 大于等于中间节点的项在右叶子；<br/>4. 分裂索引节点；<br/>5. 小于中间键的项在左索引节点；<br/>6. 大于中间键的项在右索引节点；<br/>7. 中间键上升一级；<br/>（如果上一级的索引节点还是满的，继续分裂） |

假如B+树的序数是1，order=1，一开始B+树如下所示：

![初始B+树](/images/b+tree-01.png "Initial B+ tree")

插入数据项28。首先查看叶子节点是否还有空间，若是，则把数据项插入相应的位置。

![插入叶节点](/images/b+tree-02.png "Insert data in leaf node")

插入数据项25。发现叶子节点已经没有空间了，分裂叶节点，把中间键放到对应的索引节点中。

![分裂叶节点](/images/b+tree-03.png "Split leaf node")

插入数据项8。叶子节点满，分裂叶节点，尝试把中间键放倒上层索引节点，索引节点也满，继续分裂索引节点。

![分裂索引节点](/images/b+tree-04.png "Split index node")

最后，插入数据项15。这将触发根节点分裂，如下：

![分裂根节点](/images/b+tree-05.png "Split root node")

### 删除

B+树的删除算法如下：

| 叶子页空? | 索引页空？| 动作 |
|:--------:|:-------:|-----|
| No       | No      | 删除叶子节中的记录，重新排序；<br/>如果删除的键在索引节点中，用下一个值替换它； |
| Yes      | No      | 合并叶子节点及其兄弟节点；<br/>调整索引节点； |
| Yes      | Yes     | 1. 合并叶子节点及其兄弟节点；<br/>2. 调整索引节点；<br/>3. 合并索引节点及其兄弟节点；<br/><br/>继续合并，直到索引页达到利用率或合并至根节点； |

初始B+树如下，与上面相比增加了数据项30。

![初始B+树](/images/b+tree-06.png "Initial B+ tree")

删除数据项18，它在叶子节点中，删除后如下：

![删除叶子节点](/images/b+tree-07.png "Delete data in leaf node")

删除数据项25，它在叶子节点中，且在索引节点中，需要用它的后继节点替换索引节点中的值：

![索引节点替换](/images/b+tree-08.png "Change index")

删除数据项28，这将触发合并叶子节点并更新索引节点，如下：

![合并叶子节点](/images/b+tree-09.png "Merge leaf node update index node")

删除数据项30，触发索引节点合并，直至根节点。

![合并索引节点](/images/b+tree-10.png "Merge index")

这看起来有点跳跃，当我们删除30，我们把30所在的叶子节点拿掉，将其与兄弟节点合并，导致父节点指针失效，引发再次的兄弟节点合并和父节点降级。

![索引节点降级](/images/b+tree-11.png "Downgrade Index")

继续合并索引节点。

![继续合并索引节点](/images/b+tree-12.png "Repeat Merge index")

最后删除数据项5。这涉及到叶子节点和索引节点，我们删除叶子节点并合并索引节点。

![合并右索引节点](/images/b+tree-13.png "Merge right sibling")

在这个例子中，我们删除5，引发叶子节点的合并（8，9）。消失的索引节点导致了索引节点的合并，并把它的父索引键降级。

### 旋转

可以通过旋转减少平衡树分裂的次数。如果插入时叶子节点满，但是它的兄弟还有空间，可以把插入的数据项移到兄弟节点来避免分裂。如下：

![初始B+树](/images/b+tree-14.png "Initial B+ tree")

插入数据项3，叶子节点满，但是它的兄弟节点还有空间，这时可以把数据项移动到兄弟节点，并调整索引节点。如下：

![旋转叶节点](/images/b+tree-15.png "Move data to sibling leaf node")

与插入类似，如果删除数据项13，可以将兄弟节点中的数据重新分布，如下：

![数据重新分布](/images/b+tree-16.png "Re-distribute data from the sibling node")

然后再删除数据

![删除节点](/images/b+tree-17.png "Delete Data")

参考
[CS of Colorado State University](https://www.cs.colostate.edu/~cs430dl/yr2015su/more_examples/Ch10/Tree%20indexing.pdf)