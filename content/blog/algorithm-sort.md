+++
date = "2016-08-02T11:21:46+08:00"
title = "经典排序算法总结与实现"
categories = ["Scholar"]
tags = ["Algorithm"]
description = "本文总结常见的排序算法"
slug = "algorithm-sort"
+++

经典排序算法在面试中占有很大的比重，也是基础，本文用Python实现了七大经典排序算法，包括冒泡排序，插入排序，选择排序，希尔排序，归并排序，快速排序，堆排序。之所以用Python实现，主要是因为它更接近伪代码，能用更少的代码实现算法，更利于理解。

### 冒泡排序

BubbleSort

介绍：

冒泡排序的原理非常简单，它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。

步骤：

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对第0个到第n-1个数据做同样的工作。这时，最大的数就“浮”到了数组最后的位置上。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

源代码：

```python
def bubble_sort(ary):
    n = len(ary)
    for i in xrange(n):
        for j in xrange(1, n - i):
            if ary[j - 1] > ary[j]:
                ary[j - 1], ary[j] = ary[j], ary[j - 1]
```

不过针对上述代码还有两种优化方案。

优化1：某一趟遍历如果没有数据交换，则说明已经排好序了，因此不用再进行迭代了。用一个标记记录这个状态即可。
优化2：记录某次遍历时最后发生数据交换的位置，这个位置之后的数据显然已经有序，不用再排序了。因此通过记录最后发生数据交换的位置就可以确定下次循环的范围了。

### 选择排序

SelectionSort

介绍：

选择排序无疑是最简单直观的排序。它的工作原理如下。

步骤：

1. 在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 以此类推，直到所有元素均排序完毕。

源代码：

```python
def select_sort(ary):
    n = len(ary)
    for i in xrange(n):
        min_idx = i
        for j in xrange(i + 1, n):
            if ary[min_idx] > ary[j]:
                min_idx = j
        ary[i], ary[min_idx] = ary[min_idx], ary[i]
```

### 插入排序

InsertionSort

介绍：

插入排序的工作原理是，对于每个未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

步骤：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果被扫描的元素（已排序）大于新元素，将该元素后移一位
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤2~5

排序演示：

![插入排序例子](/images/Insertion-sort-example-300px.gif "Insertion-sort-example")

源代码：

```python
def insert_sort(ary):
    n = len(ary)
    for i in xrange(1, n):
        for j in xrange(i, 0, -1):
            if ary[j - 1] > ary[j]:
                ary[j - 1], ary[j] = ary[j], ary[j - 1]
            else:
                break
```

### 希尔排序

ShellSort

介绍：

希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。

希尔排序的基本思想是：将数组列在一个表中并对列分别进行插入排序，重复这过程，不过每次用更长的列（步长更长了，列数更少了）来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。

例如，假设有这样一组数

$$
[13, 14, 94, 33, 82, 25, 59, 94, 65, 23, 45, 27, 73, 25, 39, 10]
$$

如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：

```bash
13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
```

然后我们对每列进行排序：

```bash
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
```

将上述四行数字，依序接在一起时我们得到：

$$
[10, 14, 73, 25, 23, 13, 27, 94, 33, 39, 25, 59, 94, 65, 82, 45]
$$

这时10已经移至正确位置了，然后再以3为步长进行排序：

```bash
10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
```

排序之后变为：

```bash
10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
```

最后以1步长进行排序（此时就是简单的插入排序了）。

源代码：

```python
def shell_sort(ary):
    n = len(ary)
    gap = int(round(n / 2))
    while gap > 0:
        for i in xrange(gap, n):
            tmp = ary[i]
            j = i
            while j >= gap and ary[j - gap] > tmp:
                ary[j] = ary[j - gap]
                j -= gap
            ary[j] = tmp
        gap = int(round(gap / 2))
```

上面源码的步长的选择是从n/2开始，每次再减半，直至为0。步长的选择直接决定了希尔排序的复杂度。在维基百科上有对于步长串行的详细介绍。


参考

[Jark's Blog](http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/)
